{
  "author": {
    "name": "Ben Newman",
    "email": "bn@cs.stanford.edu"
  },
  "name": "ast-types",
  "description": "Esprima-compatible implementation of the Mozilla JS Parser API",
  "keywords": [
    "ast",
    "abstract syntax tree",
    "hierarchy",
    "mozilla",
    "spidermonkey",
    "parser api",
    "esprima",
    "types",
    "type system",
    "type checking",
    "dynamic types",
    "parsing",
    "transformation",
    "syntax"
  ],
  "version": "0.3.29",
  "homepage": "http://github.com/benjamn/ast-types",
  "repository": {
    "type": "git",
    "url": "git://github.com/benjamn/ast-types.git"
  },
  "license": "MIT",
  "main": "main.js",
  "scripts": {
    "test": "mocha --reporter spec test/run.js"
  },
  "dependencies": {
    "private": "~0.1.2"
  },
  "devDependencies": {
    "esprima": "~1.1.1",
    "mocha": "~1.16.2"
  },
  "engines": {
    "node": ">= 0.6"
  },
  "readme": "AST Types\n===\n\nThis module provides an efficient, modular,\n[Esprima](https://github.com/ariya/esprima)-compatible implementation of\nthe [abstract syntax\ntree](http://en.wikipedia.org/wiki/Abstract_syntax_tree) type hierarchy\npioneered by the [Mozilla Parser\nAPI](https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API).\n\n[![Build Status](https://travis-ci.org/benjamn/ast-types.png?branch=master)](https://travis-ci.org/benjamn/ast-types)\n\nInstallation\n---\n\nFrom NPM:\n\n    npm install ast-types\n\nFrom GitHub:\n\n    cd path/to/node_modules\n    git clone git://github.com/benjamn/ast-types.git\n    cd ast-types\n    npm install .\n\nBasic Usage\n---\n```js\nvar assert = require(\"assert\");\nvar n = require(\"ast-types\").namedTypes;\nvar b = require(\"ast-types\").builders;\n\nvar fooId = b.identifier(\"foo\");\nvar ifFoo = b.ifStatement(fooId, b.blockStatement([\n    b.expressionStatement(b.callExpression(fooId, []))\n]));\n\nassert.ok(n.IfStatement.check(ifFoo));\nassert.ok(n.Statement.check(ifFoo));\nassert.ok(n.Node.check(ifFoo));\n\nassert.ok(n.BlockStatement.check(ifFoo.consequent));\nassert.strictEqual(\n    ifFoo.consequent.body[0].expression.arguments.length,\n    0);\n\nassert.strictEqual(ifFoo.test, fooId);\nassert.ok(n.Expression.check(ifFoo.test));\nassert.ok(n.Identifier.check(ifFoo.test));\nassert.ok(!n.Statement.check(ifFoo.test));\n```\n\nAST Traversal\n---\n\nBecause it understands the AST type system so thoroughly, this library\nis able to provide excellent node iteration and traversal mechanisms.\n\nHere's how you might iterate over the fields of an arbitrary AST node:\n```js\nvar copy = {};\nrequire(\"ast-types\").eachField(node, function(name, value) {\n    // Note that undefined fields will be visited too, according to\n    // the rules associated with node.type, and default field values\n    // will be substituted if appropriate.\n    copy[name] = value;\n})\n```\n\nIf you want to perform a depth-first traversal of the entire AST,\nthat's also easy:\n```js\nvar types = require(\"ast-types\");\nvar Literal = types.namedTypes.Literal;\nvar isString = types.builtInTypes.string;\nvar stringCounts = {};\n\n// Count the occurrences of all the string literals in this AST.\nrequire(\"ast-types\").traverse(ast, function(node) {\n    if (Literal.check(node) && isString.check(node.value)) {\n        if (stringCounts.hasOwnProperty(node.value)) {\n            stringCounts[node.value] += 1;\n        } else {\n            stringCounts[node.value] = 1;\n        }\n    }\n});\n```\n\nHere's an slightly deeper example demonstrating how to ignore certain\nsubtrees and inspect the node's ancestors:\n```js\nvar types = require(\"ast-types\");\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar thisProperties = {};\n\n// Populate thisProperties with every property name accessed via\n// this.name or this[\"name\"] in the current scope.\ntypes.traverse(ast, function(node) {\n    // Don't descend into new function scopes.\n    if (namedTypes.FunctionExpression.check(node) ||\n        namedTypes.FunctionDeclaration.check(node)) {\n        // Return false to stop traversing this subtree without aborting\n        // the entire traversal.\n        return false;\n    }\n\n    // If node is a ThisExpression that happens to be the .object of a\n    // MemberExpression, then we're interested in the .property of the\n    // MemberExpression. We could have inverted this test to find\n    // MemberExpressions whose .object is a ThisExpression, but I wanted\n    // to demonstrate the use of this.parent.\n    if (namedTypes.ThisExpression.check(node) &&\n        namedTypes.MemberExpression.check(this.parent.node) &&\n        this.parent.node.object === node) {\n\n        var property = this.parent.node.property;\n\n        if (namedTypes.Identifier.check(property)) {\n            // The this.name case.\n            thisProperties[property.name] = true;\n\n        } else if (namedTypes.Literal.check(property) &&\n                   isString.check(property.value)) {\n            // The this[\"name\"] case.\n            thisProperties[property.value] = true;\n        }\n    }\n});\n```\nWithin the callback function, `this` is always an instance of a simple\n`Path` type that has immutable `.node`, `.parent`, and `.scope`\nproperties. In general, `this.node` refers to the same node as the `node`\nparameter, `this.parent.node` refers to the nearest `Node` ancestor,\n`this.parent.parent.node` to the grandparent, and so on. These `Path`\nobjects are created during the traversal without modifying the AST nodes\nthemselves, so it's not a problem if the same node appears more than once\nin the AST, because it will be visited with a distict `Path` each time it\nappears.\n\nScope\n---\n\nThe object exposed as `this.scope` during AST traversals provides\ninformation about variable and function declarations in the scope that\ncontains `this.node`. See [scope.js](lib/scope.js) for its public\ninterface, which currently includes `.isGlobal`, `.getGlobalScope()`,\n`.depth`, `.declares(name)`, `.lookup(name)`, and `.getBindings()`.\n\nCustom AST Node Types\n---\n\nThe `ast-types` module was designed to be extended. To that end, it\nprovides a readable, declarative syntax for specifying new AST node types,\nbased primarily upon the `require(\"ast-types\").Type.def` function:\n```js\nvar types = require(\"ast-types\");\nvar def = types.Type.def;\nvar string = types.builtInTypes.string;\nvar b = types.builders;\n\n// Suppose you need a named File type to wrap your Programs.\ndef(\"File\")\n    .bases(\"Node\")\n    .build(\"name\", \"program\")\n    .field(\"name\", string)\n    .field(\"program\", def(\"Program\"));\n\n// Prevent further modifications to the File type (and any other\n// types newly introduced by def(...)).\ntypes.finalize();\n\n// The b.file builder function is now available. It expects two\n// arguments, as named by .build(\"name\", \"program\") above.\nvar main = b.file(\"main.js\", b.program([\n    // Pointless program contents included for extra color.\n    b.functionDeclaration(b.identifier(\"succ\"), [\n        b.identifier(\"x\")\n    ], b.blockStatement([\n        b.returnStatement(\n            b.binaryExpression(\n                \"+\", b.identifier(\"x\"), b.literal(1)\n            )\n        )\n    ]))\n]));\n\nassert.strictEqual(main.name, \"main.js\");\nassert.strictEqual(main.program.body[0].params[0].name, \"x\");\n// etc.\n\n// If you pass the wrong type of arguments, or fail to pass enough\n// arguments, an AssertionError will be thrown.\n\nb.file(b.blockStatement([]));\n// ==> AssertionError: {\"body\":[],\"type\":\"BlockStatement\",\"loc\":null} does not match type string\n\nb.file(\"lib/types.js\", b.thisExpression());\n// ==> AssertionError: {\"type\":\"ThisExpression\",\"loc\":null} does not match type Program\n```\nThe `def` syntax is used to define all the default AST node types found in\n[core.js](def/core.js),\n[es6.js](def/es6.js),\n[mozilla.js](def/mozilla.js),\n[e4x.js](def/e4x.js), and\n[fb-harmony.js](def/fb-harmony.js), so you have\nno shortage of examples to learn from.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/benjamn/ast-types/issues"
  },
  "_id": "ast-types@0.3.29",
  "_shasum": "b9f748e6228421bc848a4637592053ea6e4a6158",
  "_from": "ast-types@~0.3.29",
  "_resolved": "https://registry.npmjs.org/ast-types/-/ast-types-0.3.29.tgz"
}
